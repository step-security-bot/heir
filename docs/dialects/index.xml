<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HEIR â€“ Dialects</title><link>https://heir.dev/docs/dialects/</link><description>Recent content in Dialects on HEIR</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://heir.dev/docs/dialects/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BGV</title><link>https://heir.dev/docs/dialects/bgv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/bgv/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The BGV dialect defines the types and operations of the BGV cryptosystem.&lt;/p>
&lt;h2 id="bgv-ops">BGV ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvadd-heirbgvaddop">&lt;code>bgv.add&lt;/code> (heir::bgv::AddOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.add` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvadd_plain-heirbgvaddplainop">&lt;code>bgv.add_plain&lt;/code> (heir::bgv::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvextract-heirbgvextractop">&lt;code>bgv.extract&lt;/code> (heir::bgv::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract the i-th element of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.extract` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.&lt;/p>
&lt;p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.&lt;/p>
&lt;p>An extraction op&amp;rsquo;s input ciphertext type is asserted to have an &lt;code>underlying_type&lt;/code>
corresponding to a ranked tensor type, and this op&amp;rsquo;s return type is
inferred to have the &lt;code>underlying_type&lt;/code> corresponding to the element type of
that tensor type.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>offset&lt;/code>&lt;/td>
&lt;td>signless integer or index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmodulus_switch-heirbgvmodulusswitchop">&lt;code>bgv.modulus_switch&lt;/code> (heir::bgv::ModulusSwitchOp)&lt;/h3>
&lt;p>&lt;em>Lower the modulus level of the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.modulus_switch` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_ring&lt;/code>&lt;/td>&lt;td>::mlir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmul-heirbgvmulop">&lt;code>bgv.mul&lt;/code> (heir::bgv::MulOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmul_plain-heirbgvmulplainop">&lt;code>bgv.mul_plain&lt;/code> (heir::bgv::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvnegate-heirbgvnegateop">&lt;code>bgv.negate&lt;/code> (heir::bgv::NegateOp)&lt;/h3>
&lt;p>&lt;em>Negate the coefficients of the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.negate` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvrelinearize-heirbgvrelinearizeop">&lt;code>bgv.relinearize&lt;/code> (heir::bgv::RelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.relinearize` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>This op takes integer array attributes &lt;code>from_basis&lt;/code> and &lt;code>to_basis&lt;/code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
&lt;code>(1, s)&lt;/code>. After a multiplication, its size will increase and the basis will be
&lt;code>(1, s, s^2)&lt;/code>. The array that represents the key basis is constructed by
listing the powers of &lt;code>s&lt;/code> at each position of the array. For example, &lt;code>(1, s, s^2)&lt;/code> corresponds to &lt;code>[0, 1, 2]&lt;/code>, while &lt;code>(1, s^2)&lt;/code> corresponds to &lt;code>[0, 2]&lt;/code>.&lt;/p>
&lt;p>Traits: &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>from_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvrotate-heirbgvrotateop">&lt;code>bgv.rotate&lt;/code> (heir::bgv::RotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate the coefficients of the ciphertext using a Galois automorphism.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.rotate` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvsub-heirbgvsubop">&lt;code>bgv.sub&lt;/code> (heir::bgv::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.sub` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvsub_plain-heirbgvsubplainop">&lt;code>bgv.sub_plain&lt;/code> (heir::bgv::SubPlainOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.sub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: CGGI</title><link>https://heir.dev/docs/dialects/cggi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/cggi/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>A dialect for types and operations in the CGGI cryptosystem&lt;/p>
&lt;h2 id="cggi-attributes">CGGI attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="cggigateattr">CGGIGateAttr&lt;/h3>
&lt;p>An Attribute containing an array of strings to store bool gates&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#cggi.cggi_gate&amp;lt;
::llvm::ArrayRef&amp;lt;mlir::StringAttr&amp;gt; # gate
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attributes stores a list of string identifiers for Boolean gates.&lt;/p>
&lt;p>This used in the &lt;code>cggi.packed&lt;/code> operation to indicate the boolean gate that applies pairwise between elements of two ciphertext arrays. For example,&lt;/p>
&lt;p>%0 = cggi.packed %a, %b {gates = #cggi.cggi_gate&amp;lt;&amp;ldquo;and&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;&amp;gt;} : tensor&amp;lt;2x!lwe.lwe_ciphertext&amp;gt;&lt;/p>
&lt;p>applies an &amp;ldquo;and&amp;rdquo; gate between the first elements of %a and %b and an xor gate between the second elements.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">gate&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;mlir::StringAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggiparamsattr">CGGIParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#cggi.cggi_params&amp;lt;
::mlir::heir::lwe::RLWEParamsAttr, # rlweParams
unsigned, # bsk_noise_variance
unsigned, # bsk_gadget_base_log
unsigned, # bsk_gadget_num_levels
unsigned, # ksk_noise_variance
unsigned, # ksk_gadget_base_log
unsigned # ksk_gadget_num_levels
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlweParams&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::lwe::RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_noise_variance&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_gadget_base_log&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_gadget_num_levels&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_noise_variance&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_gadget_base_log&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_gadget_num_levels&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="cggi-ops">CGGI ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="cggiand-heircggiandop">&lt;code>cggi.and&lt;/code> (heir::cggi::AndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.and` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut2-heircggilut2op">&lt;code>cggi.lut2&lt;/code> (heir::cggi::Lut2Op)&lt;/h3>
&lt;p>&lt;em>A lookup table on two inputs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut2` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to some number &lt;code>n&lt;/code> of ciphertexts
encrypting boolean input bits.&lt;/p>
&lt;p>Over cleartext bits &lt;code>a, b, c&lt;/code>, using &lt;code>n = 3&lt;/code> for example, the operation
computed by this function can be interpreted as&lt;/p>
&lt;pre tabindex="0">&lt;code> truth_table &amp;gt;&amp;gt; {c, b, a}
&lt;/code>&lt;/pre>&lt;p>where &lt;code>{c, b, a}&lt;/code> is the unsigned 3-bit integer with bits &lt;code>c, b, a&lt;/code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut3-heircggilut3op">&lt;code>cggi.lut3&lt;/code> (heir::cggi::Lut3Op)&lt;/h3>
&lt;p>&lt;em>A lookup table on three inputs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut3` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to some number &lt;code>n&lt;/code> of ciphertexts
encrypting boolean input bits.&lt;/p>
&lt;p>Over cleartext bits &lt;code>a, b, c&lt;/code>, using &lt;code>n = 3&lt;/code> for example, the operation
computed by this function can be interpreted as&lt;/p>
&lt;pre tabindex="0">&lt;code> truth_table &amp;gt;&amp;gt; {c, b, a}
&lt;/code>&lt;/pre>&lt;p>where &lt;code>{c, b, a}&lt;/code> is the unsigned 3-bit integer with bits &lt;code>c, b, a&lt;/code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut_lincomb-heircggilutlincombop">&lt;code>cggi.lut_lincomb&lt;/code> (heir::cggi::LutLinCombOp)&lt;/h3>
&lt;p>&lt;em>A variadic-input lookup table with inputs prepared via linear combination.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut_lincomb` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to an arbitrary number of
input ciphertexts, which are combined according to a static linear
combination attached to the op.&lt;/p>
&lt;p>The user must ensure the chosen linear combination does not bleed error
bits into the message space according to the underlying ciphertext&amp;rsquo;s
encoding attributes. E.g., a bit_field_encoding with 3 cleartext bits
cannot be multiplied by 16.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#encoding&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.bit_field_encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cleartext_start=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">30&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">cleartext_bitwidth=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#params&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.lwe_params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cmod=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7917&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">dimension=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">ciphertext =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>lwe&lt;span style="color:#000;font-weight:bold">.&lt;/span>lwe_ciphertext&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">encoding =&lt;/span> &lt;span style="color:#000">#encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">lwe_params =&lt;/span> &lt;span style="color:#000">#params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%4&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> cggi&lt;span style="color:#000;font-weight:bold">.&lt;/span>lut_lincomb &lt;span style="color:#000">%c0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c3&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f57900">coefficients =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#f57900">lookup_table =&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">68&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Represents applying the lut&lt;/p>
&lt;pre tabindex="0">&lt;code> 68 &amp;gt;&amp;gt; (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>coefficients&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggimulti_lut_lincomb-heircggimultilutlincombop">&lt;code>cggi.multi_lut_lincomb&lt;/code> (heir::cggi::MultiLutLinCombOp)&lt;/h3>
&lt;p>&lt;em>A multi-output version of lut_lincomb with one LUT per output.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.multi_lut_lincomb` operands attr-dict `:` functional-type($inputs, $outputs)
&lt;/code>&lt;/pre>&lt;p>An op representing multiple lookup tables applied to a shared input, which
is prepared via a static linear combination. This is equivalent to
&lt;code>cggi.lut_lincomb&lt;/code>, but where the linear combination is given to multiple
lookup tables, each producing a separate output.&lt;/p>
&lt;p>This can be achieved by a special implementation of blind rotate in the CGGI
scheme. See &lt;a href="https://ieeexplore.ieee.org/document/10413195">AutoHoG&lt;/a>.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#encoding&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.bit_field_encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cleartext_start=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">30&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">cleartext_bitwidth=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#params&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.lwe_params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cmod=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7917&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">dimension=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">ciphertext =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>lwe&lt;span style="color:#000;font-weight:bold">.&lt;/span>lwe_ciphertext&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">encoding =&lt;/span> &lt;span style="color:#000">#encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">lwe_params =&lt;/span> &lt;span style="color:#000">#params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%4&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> cggi&lt;span style="color:#000;font-weight:bold">.&lt;/span>multi_lut_lincomb &lt;span style="color:#000">%c0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c3&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">coefficients =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">lookup_tables =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">68&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">70&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Represents applying the following LUTs. Performance-wise, this is
comparable to applying a single LUT to a linear combination.&lt;/p>
&lt;pre tabindex="0">&lt;code>x = (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
return (
(68 &amp;gt;&amp;gt; x) &amp;amp; 1,
(70 &amp;gt;&amp;gt; x) &amp;amp; 1,
(4 &amp;gt;&amp;gt; x) &amp;amp; 1,
(8 &amp;gt;&amp;gt; x) &amp;amp; 1
)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>coefficients&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_tables&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>outputs&lt;/code>&lt;/td>
&lt;td>variadic of A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginand-heircgginandop">&lt;code>cggi.nand&lt;/code> (heir::cggi::NandOp)&lt;/h3>
&lt;p>&lt;em>Logical NAND of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.nand` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginor-heircgginorop">&lt;code>cggi.nor&lt;/code> (heir::cggi::NorOp)&lt;/h3>
&lt;p>&lt;em>Logical NOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.nor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginot-heircgginotop">&lt;code>cggi.not&lt;/code> (heir::cggi::NotOp)&lt;/h3>
&lt;p>&lt;em>Logical NOT of two ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.not` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggior-heircggiorop">&lt;code>cggi.or&lt;/code> (heir::cggi::OrOp)&lt;/h3>
&lt;p>&lt;em>Logical OR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.or` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggipacked_gates-heircggipackedop">&lt;code>cggi.packed_gates&lt;/code> (heir::cggi::PackedOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.packed_gates` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>gates&lt;/code>&lt;/td>&lt;td>::mlir::heir::cggi::CGGIGateAttr&lt;/td>&lt;td>An Attribute containing an array of strings to store bool gates&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggixnor-heircggixnorop">&lt;code>cggi.xnor&lt;/code> (heir::cggi::XNorOp)&lt;/h3>
&lt;p>&lt;em>Logical XNOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.xnor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggixor-heircggixorop">&lt;code>cggi.xor&lt;/code> (heir::cggi::XorOp)&lt;/h3>
&lt;p>&lt;em>Logical XOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.xor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: CKKS</title><link>https://heir.dev/docs/dialects/ckks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/ckks/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The CKKS dialect defines the types and operations of the CKKS cryptosystem.&lt;/p>
&lt;h2 id="ckks-ops">CKKS ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ckksadd-heirckksaddop">&lt;code>ckks.add&lt;/code> (heir::ckks::AddOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.add` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksadd_plain-heirckksaddplainop">&lt;code>ckks.add_plain&lt;/code> (heir::ckks::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksextract-heirckksextractop">&lt;code>ckks.extract&lt;/code> (heir::ckks::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract the i-th element of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.extract` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.&lt;/p>
&lt;p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.&lt;/p>
&lt;p>An extraction op&amp;rsquo;s input ciphertext type is asserted to have an &lt;code>underlying_type&lt;/code>
corresponding to a ranked tensor type, and this op&amp;rsquo;s return type is
inferred to have the &lt;code>underlying_type&lt;/code> corresponding to the element type of
that tensor type.&lt;/p>
&lt;p>Traits: &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>offset&lt;/code>&lt;/td>
&lt;td>signless integer or index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksmul-heirckksmulop">&lt;code>ckks.mul&lt;/code> (heir::ckks::MulOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksmul_plain-heirckksmulplainop">&lt;code>ckks.mul_plain&lt;/code> (heir::ckks::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksnegate-heirckksnegateop">&lt;code>ckks.negate&lt;/code> (heir::ckks::NegateOp)&lt;/h3>
&lt;p>&lt;em>Negate the coefficients of the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.negate` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrelinearize-heirckksrelinearizeop">&lt;code>ckks.relinearize&lt;/code> (heir::ckks::RelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.relinearize` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>This op takes integer array attributes &lt;code>from_basis&lt;/code> and &lt;code>to_basis&lt;/code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
&lt;code>(1, s)&lt;/code>. After a multiplication, its size will increase and the basis will be
&lt;code>(1, s, s^2)&lt;/code>. The array that represents the key basis is constructed by
listing the powers of &lt;code>s&lt;/code> at each position of the array. For example, &lt;code>(1, s, s^2)&lt;/code> corresponds to &lt;code>[0, 1, 2]&lt;/code>, while &lt;code>(1, s^2)&lt;/code> corresponds to &lt;code>[0, 2]&lt;/code>.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>from_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrescale-heirckksrescaleop">&lt;code>ckks.rescale&lt;/code> (heir::ckks::RescaleOp)&lt;/h3>
&lt;p>&lt;em>Rescales the ciphertext, which is the CKKS version of modulus switching in BGV/BFV.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.rescale` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_ring&lt;/code>&lt;/td>&lt;td>::mlir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrotate-heirckksrotateop">&lt;code>ckks.rotate&lt;/code> (heir::ckks::RotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate the coefficients of the ciphertext using a Galois automorphism.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.rotate` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckkssub-heirckkssubop">&lt;code>ckks.sub&lt;/code> (heir::ckks::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.sub` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckkssub_plain-heirckkssubplainop">&lt;code>ckks.sub_plain&lt;/code> (heir::ckks::SubPlainOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.sub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintextInput&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Comb</title><link>https://heir.dev/docs/dialects/comb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/comb/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>Types and operations for comb dialect
This dialect defines the &lt;code>comb&lt;/code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.&lt;/p>
&lt;h2 id="operations">Operations&lt;/h2>
&lt;h3 id="combadd-heircombaddop">&lt;code>comb.add&lt;/code> (heir::comb::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comband-heircombandop">&lt;code>comb.and&lt;/code> (heir::comb::AndOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combconcat-heircombconcatop">&lt;code>comb.concat&lt;/code> (heir::comb::ConcatOp)&lt;/h3>
&lt;p>&lt;em>Concatenate a variadic list of operands together.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
&lt;/code>&lt;/pre>&lt;p>See the comb rationale document for details on operand ordering.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combextract-heircombextractop">&lt;code>comb.extract&lt;/code> (heir::comb::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lowBit&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>32-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combicmp-heircombicmpop">&lt;code>comb.icmp&lt;/code> (heir::comb::ICmpOp)&lt;/h3>
&lt;p>&lt;em>Compare two integer values&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
&lt;/code>&lt;/pre>&lt;p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.&lt;/p>
&lt;pre tabindex="0">&lt;code> %r = comb.icmp eq %a, %b : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::heir::comb::ICmpPredicateAttr&lt;/td>&lt;td>hw.icmp comparison predicate&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combinv-heircombinvop">&lt;code>comb.inv&lt;/code> (heir::comb::InvOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmul-heircombmulop">&lt;code>comb.mul&lt;/code> (heir::comb::MulOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmux-heircombmuxop">&lt;code>comb.mux&lt;/code> (heir::comb::MuxOp)&lt;/h3>
&lt;p>&lt;em>Return one or the other operand depending on a selector bit&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %0 = mux %pred, %tvalue, %fvalue : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-6">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cond&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnand-heircombnandop">&lt;code>comb.nand&lt;/code> (heir::comb::NandOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-7">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnor-heircombnorop">&lt;code>comb.nor&lt;/code> (heir::comb::NorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-8">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combor-heircomborop">&lt;code>comb.or&lt;/code> (heir::comb::OrOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-9">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combparity-heircombparityop">&lt;code>comb.parity&lt;/code> (heir::comb::ParityOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-10">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combreplicate-heircombreplicateop">&lt;code>comb.replicate&lt;/code> (heir::comb::ReplicateOp)&lt;/h3>
&lt;p>&lt;em>Concatenate the operand a constant number of times&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combtruth_table-heircombtruthtableop">&lt;code>comb.truth_table&lt;/code> (heir::comb::TruthTableOp)&lt;/h3>
&lt;p>&lt;em>Return a true/false based on a lookup table&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.truth_table` $inputs `-&amp;gt;` $lookupTable attr-dict
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %a = ... : i1
%b = ... : i1
%0 = comb.truth_table %a, %b -&amp;gt; 6 : ui4
&lt;/code>&lt;/pre>&lt;p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -&amp;gt; LSB from left
to right and the offset into &lt;code>lookupTable&lt;/code> is computed from them. The
integer containing the truth table value&amp;rsquo;s LSB is the output for the input
&amp;ldquo;all false&amp;rdquo;, and the MSB is the output for the input &amp;ldquo;all true&amp;rdquo;.&lt;/p>
&lt;p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&amp;rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &amp;lsquo;x&amp;rsquo; &amp;ndash; it should be the well-known result.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-11">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookupTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of 1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxnor-heircombxnorop">&lt;code>comb.xnor&lt;/code> (heir::comb::XNorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-12">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxor-heircombxorop">&lt;code>comb.xor&lt;/code> (heir::comb::XorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-13">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="enums">Enums&lt;/h2>
&lt;h3 id="icmppredicate">ICmpPredicate&lt;/h3>
&lt;p>hw.icmp comparison predicate&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">eq&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>eq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ne&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>ne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">slt&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>slt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sle&lt;/td>
&lt;td style="text-align:center">&lt;code>3&lt;/code>&lt;/td>
&lt;td>sle&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sgt&lt;/td>
&lt;td style="text-align:center">&lt;code>4&lt;/code>&lt;/td>
&lt;td>sgt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sge&lt;/td>
&lt;td style="text-align:center">&lt;code>5&lt;/code>&lt;/td>
&lt;td>sge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ult&lt;/td>
&lt;td style="text-align:center">&lt;code>6&lt;/code>&lt;/td>
&lt;td>ult&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ule&lt;/td>
&lt;td style="text-align:center">&lt;code>7&lt;/code>&lt;/td>
&lt;td>ule&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ugt&lt;/td>
&lt;td style="text-align:center">&lt;code>8&lt;/code>&lt;/td>
&lt;td>ugt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">uge&lt;/td>
&lt;td style="text-align:center">&lt;code>9&lt;/code>&lt;/td>
&lt;td>uge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ceq&lt;/td>
&lt;td style="text-align:center">&lt;code>10&lt;/code>&lt;/td>
&lt;td>ceq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cne&lt;/td>
&lt;td style="text-align:center">&lt;code>11&lt;/code>&lt;/td>
&lt;td>cne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">weq&lt;/td>
&lt;td style="text-align:center">&lt;code>12&lt;/code>&lt;/td>
&lt;td>weq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">wne&lt;/td>
&lt;td style="text-align:center">&lt;code>13&lt;/code>&lt;/td>
&lt;td>wne&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="comb-types">Comb types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h2 id="comb-ops">Comb ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="combadd-heircombaddop-1">&lt;code>comb.add&lt;/code> (heir::comb::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-14">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comband-heircombandop-1">&lt;code>comb.and&lt;/code> (heir::comb::AndOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-15">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combconcat-heircombconcatop-1">&lt;code>comb.concat&lt;/code> (heir::comb::ConcatOp)&lt;/h3>
&lt;p>&lt;em>Concatenate a variadic list of operands together.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
&lt;/code>&lt;/pre>&lt;p>See the comb rationale document for details on operand ordering.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combextract-heircombextractop-1">&lt;code>comb.extract&lt;/code> (heir::comb::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-16">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lowBit&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>32-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combicmp-heircombicmpop-1">&lt;code>comb.icmp&lt;/code> (heir::comb::ICmpOp)&lt;/h3>
&lt;p>&lt;em>Compare two integer values&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
&lt;/code>&lt;/pre>&lt;p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.&lt;/p>
&lt;pre tabindex="0">&lt;code> %r = comb.icmp eq %a, %b : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-17">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::heir::comb::ICmpPredicateAttr&lt;/td>&lt;td>hw.icmp comparison predicate&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combinv-heircombinvop-1">&lt;code>comb.inv&lt;/code> (heir::comb::InvOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-18">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-21">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmul-heircombmulop-1">&lt;code>comb.mul&lt;/code> (heir::comb::MulOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-19">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-22">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-22">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmux-heircombmuxop-1">&lt;code>comb.mux&lt;/code> (heir::comb::MuxOp)&lt;/h3>
&lt;p>&lt;em>Return one or the other operand depending on a selector bit&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %0 = mux %pred, %tvalue, %fvalue : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-20">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-23">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cond&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-23">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnand-heircombnandop-1">&lt;code>comb.nand&lt;/code> (heir::comb::NandOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-21">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-24">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-24">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnor-heircombnorop-1">&lt;code>comb.nor&lt;/code> (heir::comb::NorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-22">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-25">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-25">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combor-heircomborop-1">&lt;code>comb.or&lt;/code> (heir::comb::OrOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-23">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-26">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-26">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combparity-heircombparityop-1">&lt;code>comb.parity&lt;/code> (heir::comb::ParityOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-24">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-27">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-27">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combreplicate-heircombreplicateop-1">&lt;code>comb.replicate&lt;/code> (heir::comb::ReplicateOp)&lt;/h3>
&lt;p>&lt;em>Concatenate the operand a constant number of times&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-28">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-28">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combtruth_table-heircombtruthtableop-1">&lt;code>comb.truth_table&lt;/code> (heir::comb::TruthTableOp)&lt;/h3>
&lt;p>&lt;em>Return a true/false based on a lookup table&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.truth_table` $inputs `-&amp;gt;` $lookupTable attr-dict
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %a = ... : i1
%b = ... : i1
%0 = comb.truth_table %a, %b -&amp;gt; 6 : ui4
&lt;/code>&lt;/pre>&lt;p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -&amp;gt; LSB from left
to right and the offset into &lt;code>lookupTable&lt;/code> is computed from them. The
integer containing the truth table value&amp;rsquo;s LSB is the output for the input
&amp;ldquo;all false&amp;rdquo;, and the MSB is the output for the input &amp;ldquo;all true&amp;rdquo;.&lt;/p>
&lt;p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&amp;rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &amp;lsquo;x&amp;rsquo; &amp;ndash; it should be the well-known result.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-25">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookupTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-29">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of 1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-29">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxnor-heircombxnorop-1">&lt;code>comb.xnor&lt;/code> (heir::comb::XNorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-26">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-30">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-30">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxor-heircombxorop-1">&lt;code>comb.xor&lt;/code> (heir::comb::XorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-27">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-31">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-31">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Jaxite</title><link>https://heir.dev/docs/dialects/jaxite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/jaxite/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The &lt;code>jaxite&lt;/code> dialect is an exit dialect for generating py code against the jaxite library API,
using the jaxite parameters and encoding scheme.&lt;/p>
&lt;p>See &lt;a href="https://github.com/google/jaxite">https://github.com/google/jaxite&lt;/a>&lt;/p>
&lt;h2 id="jaxite-types">Jaxite types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="paramstype">ParamsType&lt;/h3>
&lt;p>The jaxite security params required to perform homomorphic operations.&lt;/p>
&lt;p>Syntax: &lt;code>!jaxite.params&lt;/code>&lt;/p>
&lt;h3 id="serverkeysettype">ServerKeySetType&lt;/h3>
&lt;p>The jaxite server key set required to perform homomorphic operations.&lt;/p>
&lt;p>Syntax: &lt;code>!jaxite.server_key_set&lt;/code>&lt;/p>
&lt;h2 id="jaxite-ops">Jaxite ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="jaxiteconstant-heirjaxiteconstantop">&lt;code>jaxite.constant&lt;/code> (heir::jaxite::ConstantOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.constant` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The jaxite security params required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="jaxitelut3-heirjaxitelut3op">&lt;code>jaxite.lut3&lt;/code> (heir::jaxite::Lut3Op)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.lut3` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>The operation computed by this function can be
interpreted as&lt;/p>
&lt;p>truth_table &amp;raquo; {c, b, a}&lt;/p>
&lt;p>where {c, b, a} is the unsigned 3-bit integer with bits c, b, a from most
significant bit to least-significant bit.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>truth_table&lt;/code>&lt;/td>
&lt;td>8-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKeySet&lt;/code>&lt;/td>
&lt;td>The jaxite server key set required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The jaxite security params required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: LWE</title><link>https://heir.dev/docs/dialects/lwe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/lwe/</guid><description>
&lt;h2 id="lwe-attributes">LWE attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bitfieldencodingattr">BitFieldEncodingAttr&lt;/h3>
&lt;p>An attribute describing encoded LWE plaintexts using bit fields.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.bit_field_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.&lt;/p>
&lt;p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit &lt;code>bit_width-1&lt;/code>. So the above example would have starting bit &lt;code>30&lt;/code> and
width &lt;code>3&lt;/code>. The bits not specified for the message have semantics defined
by the scheme or lowering.&lt;/p>
&lt;p>Note that this encoding does not specify the underlying bit width of the
plaintext space. This is left for lowerings to decide.&lt;/p>
&lt;p>The presence of this attribute as the &lt;code>encoding&lt;/code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.&lt;/p>
&lt;p>&lt;strong>Example (CGGI):&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#encoding = #lwe.bit_field_encoding&amp;lt;cleartext_start=30, cleartext_bitwidth=3&amp;gt;
!plaintext = !lwe.lwe_plaintext&amp;lt;encoding = #encoding&amp;gt;
%0 = arith.constant 4 : i3
%1 = lwe.encode %0 { encoding = #encoding }: i3 to !plaintext
&lt;/code>&lt;/pre>&lt;p>The above represents an LWE plaintext encoding the 3-bit cleartext 4 as an
LWE ciphertext in a 32-bit integer, with a single bit of padding at the MSB.
This corresponds to the following, where 0 denotes a 0 bit, &lt;code>b&lt;/code> denotes a
bit of the cleartext, &lt;code>n&lt;/code> denotes a bit reserved for noise, and &lt;code>|&lt;/code> is a
visual aid to show where the bit fields begin and end.&lt;/p>
&lt;pre tabindex="0">&lt;code> 0|bbb|nn...n
MSB^ ^LSB
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example (BGV):&lt;/strong>&lt;/p>
&lt;p>Note: BGV uses the RLWE encodings, but they have the same bit-field encoding
attributes as here. So this example serves mainly to show how this attribute
can be used to specify storing bits in the LSB of a plaintext.&lt;/p>
&lt;pre tabindex="0">&lt;code>#encoding = #lwe.bit_field_encoding&amp;lt;cleartext_start=4, cleartext_bitwidth=4&amp;gt;
!plaintext = !lwe.lwe_plaintext&amp;lt;encoding = #encoding&amp;gt;
%0 = arith.constant 9 : i4
%1 = lwe.encode %0 { encoding = #encoding }: i4 to !plaintext
&lt;/code>&lt;/pre>&lt;p>The above represents an LWE plaintext encoding a 4-bit cleartext as an
LWE ciphertext in the least-significant bits of a larger integer.
This corresponds to the following.&lt;/p>
&lt;pre tabindex="0">&lt;code> nn...n|bbbb
MSB^ ^LSB
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweparamsattr">LWEParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.lwe_params&amp;lt;
IntegerAttr, # cmod
unsigned # dimension
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cmod&lt;/td>
&lt;td style="text-align:center">&lt;code>IntegerAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">dimension&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweparamsattr">RLWEParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.rlwe_params&amp;lt;
unsigned, # dimension
::mlir::polynomial::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing classical RLWE parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>dimension&lt;/code>: the number of polynomials used in an RLWE sample, analogous
to LWEParams.dimension.&lt;/li>
&lt;li>&lt;code>ring&lt;/code>: the polynomial ring to use.&lt;/li>
&lt;/ul>
&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">dimension&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="unspecifiedbitfieldencodingattr">UnspecifiedBitFieldEncodingAttr&lt;/h3>
&lt;p>An attribute describing unspecified bit field encodings.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.unspecified_bit_field_encoding&amp;lt;
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>See LWE_BitFieldEncoding for a description of bit field encodings.&lt;/p>
&lt;p>This attribute describes an unspecified bit field encoding; this is where
the starting bit position of the cleartext bit field is unspecified, but its
width is fixed. A noise growth analysis should be performed to determine the
optimal amount of bits needed for noise and padding to specify the bit field
encodings starting bit position.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe_encoding = #lwe.unspecified_bit_field_encoding&amp;lt;cleartext_bitwidth=3&amp;gt;
%lwe_ciphertext = arith.constant &amp;lt;[1,2,3,4]&amp;gt; : tensor&amp;lt;4xi32, #lwe_encoding&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-3">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="inversecanonicalembeddingencodingattr">InverseCanonicalEmbeddingEncodingAttr&lt;/h3>
&lt;p>An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.inverse_canonical_embedding_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Let $n$ be the degree of the polynomials in the plaintext space. An
&amp;ldquo;inverse canonical embedding encoding&amp;rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.&lt;/p>
&lt;p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:&lt;/p>
&lt;p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]&lt;/p>
&lt;p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.&lt;/p>
&lt;p>The map $\tau_N$ is derived from the so-called &lt;em>canonical embedding&lt;/em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.&lt;/p>
&lt;p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.&lt;/p>
&lt;p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an &lt;em>integer&lt;/em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.&lt;/p>
&lt;p>The scaling parameter $\Delta$ is specified by the &lt;code>cleartext_start&lt;/code> and
&lt;code>cleartext_bitwidth&lt;/code> parameters, which are applied coefficient-wise using
the same semantics as the &lt;code>bit_field_encoding&lt;/code>.&lt;/p>
&lt;p>This attribute can be used in multiple ways:&lt;/p>
&lt;ul>
&lt;li>On a &lt;code>poly.poly&lt;/code>, it asserts that the polynomial has been transformed
from a coefficient list using the canonical embedding.&lt;/li>
&lt;li>On a tensor of &lt;code>poly.poly&lt;/code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the approximate embedding
encoding.&lt;/li>
&lt;/ul>
&lt;p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&amp;rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#generator = #poly.polynomial&amp;lt;1 + x**1024&amp;gt;
#ring = #poly.ring&amp;lt;cmod=65536, ideal=#generator&amp;gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&amp;lt;cleartext_start=30, cleartext_bitwidth=3&amp;gt;
%evals = arith.constant &amp;lt;[1, 2, 4, 5]&amp;gt; : tensor&amp;lt;4xi16&amp;gt;
%poly1 = poly.intt %evals : tensor&amp;lt;4xi16, #ring&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;
%poly2 = poly.intt %evals : tensor&amp;lt;4xi16, #ring&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&amp;lt;2x!poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>See &lt;code>bit_field_encoding&lt;/code> for the definition of the &lt;code>cleartext_start&lt;/code> and
&lt;code>cleartext_bitwidth&lt;/code> fields.&lt;/p>
&lt;h4 id="parameters-4">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialcoefficientencodingattr">PolynomialCoefficientEncodingAttr&lt;/h3>
&lt;p>An attribute describing encoded RLWE plaintexts via coefficients.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.polynomial_coefficient_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the cleartexts, with the same semantics as
&lt;code>bit_field_encoding&lt;/code> for per-coefficient encodings.&lt;/p>
&lt;p>The presence of this attribute as the &lt;code>encoding&lt;/code> attribute of a tensor of
&lt;code>poly.poly&lt;/code> indicates that the tensor is an RLWE ciphertext for some RLWE
scheme that supports the coefficient encoding.&lt;/p>
&lt;p>See &lt;code>bit_field_encoding&lt;/code> for the definition of the &lt;code>cleartext_start&lt;/code> and
&lt;code>cleartext_bitwidth&lt;/code> fields.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#generator = #poly.polynomial&amp;lt;1 + x**1024&amp;gt;
#ring = #poly.ring&amp;lt;cmod=65536, ideal=#generator&amp;gt;
#coeff_encoding = #lwe.polynomial_coefficient_encoding&amp;lt;cleartext_start=15, cleartext_bitwidth=4&amp;gt;
%poly1 = poly.from_tensor %coeffs1 : tensor&amp;lt;10xi16&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring&amp;gt;
%poly2 = poly.from_tensor %coeffs2 : tensor&amp;lt;10xi16&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring&amp;gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&amp;lt;2x!poly.poly&amp;lt;#ring&amp;gt;, #coeff_encoding&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-5">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialevaluationencodingattr">PolynomialEvaluationEncodingAttr&lt;/h3>
&lt;p>An attribute describing encoded RLWE plaintexts via evaluations at fixed points.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.polynomial_evaluation_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A &amp;ldquo;evaluation encoding&amp;rdquo; of a list of integers $(v_1, \dots, v_n)$ asserts
that $f(x_1 ) = v_1, \dots, f(x_n) = v_n$ for some implicit, but fixed and
distinct choice of inputs $x_i$. The encoded values are also scaled by a
scale factor, having the same semantics as &lt;code>bit_field_encoding&lt;/code>, but
applied entry-wise (to either the coefficient or evaluation representation).&lt;/p>
&lt;p>This attribute can be used in multiple ways:&lt;/p>
&lt;ul>
&lt;li>On a &lt;code>poly.poly&lt;/code>, it asserts that the polynomial has been transformed
from an evaluation tensor.&lt;/li>
&lt;li>On a tensor of &lt;code>poly.poly&lt;/code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the evaluation encoding.&lt;/li>
&lt;/ul>
&lt;p>A typical workflow for the BFV/BGV schemes using this encoding would be
to apply a INTT operation to the input list of cleartexts to convert from
evaluation form to coefficient form, then encrypt the resulting polynomial
in coefficient form, then apply NTT back to the evaluation form for faster
multiplication of ciphertexts.&lt;/p>
&lt;p>The points chosen are fixed to be the powers of a primitive root of unity
of the coefficient ring of the plaintext space, which allows one to use
NTT/INTT to tansform quickly between the coefficient and evaluation forms.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#generator = #poly.polynomial&amp;lt;1 + x**1024&amp;gt;
// note that the cmod should be chosen so as to ensure a primitive root of
// unity exists in the multiplicative group (Z / cmod Z)^*
#ring = #poly.ring&amp;lt;cmod=65536, ideal=#generator&amp;gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&amp;lt;cleartext_start=30, cleartext_bitwidth=3&amp;gt;
%evals = arith.constant &amp;lt;[1, 2, 4, 5]&amp;gt; : tensor&amp;lt;4xi16&amp;gt;
%poly1 = poly.intt %evals : tensor&amp;lt;4xi16, #ring&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;
%poly2 = poly.intt %evals : tensor&amp;lt;4xi16, #ring&amp;gt; -&amp;gt; !poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&amp;lt;2x!poly.poly&amp;lt;#ring, #eval_encoding&amp;gt;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>See &lt;code>bit_field_encoding&lt;/code> for the definition of the &lt;code>cleartext_start&lt;/code> and
&lt;code>cleartext_bitwidth&lt;/code> fields.&lt;/p>
&lt;h4 id="parameters-6">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lwe-types">LWE types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lweciphertexttype">LWECiphertextType&lt;/h3>
&lt;p>A type for LWE ciphertexts&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.lwe_ciphertext&amp;lt;
::mlir::Attribute, # encoding
LWEParamsAttr # lwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for LWE ciphertexts.&lt;/p>
&lt;p>This type keeps track of the plaintext integer encoding for the LWE
Ciphertext to ensure proper decoding after decryption. It also keeps track
of the ring where the LWE ciphertext is defined, which provides information
on the ciphertext shape and the ring operations used in LWE operations.&lt;/p>
&lt;h4 id="parameters-7">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">lwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>LWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweplaintexttype">LWEPlaintextType&lt;/h3>
&lt;p>A type for LWE plaintexts&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.lwe_plaintext&amp;lt;
::mlir::Attribute # encoding
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for LWE plaintexts.&lt;/p>
&lt;p>This type keeps track of the plaintext integer encoding for the LWE
plaintext before it is encrypted.&lt;/p>
&lt;h4 id="parameters-8">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweciphertexttype">RLWECiphertextType&lt;/h3>
&lt;p>A type for RLWE ciphertexts&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_ciphertext&amp;lt;
::mlir::Attribute, # encoding
RLWEParamsAttr, # rlwe_params
Type # underlying_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-9">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">underlying_type&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweplaintexttype">RLWEPlaintextType&lt;/h3>
&lt;p>A type for RLWE plaintexts&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_plaintext&amp;lt;
::mlir::Attribute, # encoding
::mlir::polynomial::RingAttr, # ring
Type # underlying_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-10">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">underlying_type&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlwepublickeytype">RLWEPublicKeyType&lt;/h3>
&lt;p>A public key for RLWE&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_public_key&amp;lt;
RLWEParamsAttr # rlwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-11">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlwesecretkeytype">RLWESecretKeyType&lt;/h3>
&lt;p>A secret key for RLWE&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_secret_key&amp;lt;
RLWEParamsAttr # rlwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-12">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lwe-ops">LWE ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lweadd-heirlweaddop">&lt;code>lwe.add&lt;/code> (heir::lwe::AddOp)&lt;/h3>
&lt;p>&lt;em>Add two LWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.add` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweencode-heirlweencodeop">&lt;code>lwe.encode&lt;/code> (heir::lwe::EncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode an integer to yield an LWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.encode` $plaintext attr-dict `:` qualified(type($plaintext)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Encode an integer to yield an LWE plaintext.&lt;/p>
&lt;p>This op uses a an encoding attribute to encode the bits of the integer into
an LWE plaintext value that can then be encrypted.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%Y = lwe.encode %value {encoding = #enc}: i1 to !lwe.lwe_plaintext&amp;lt;encoding = #enc&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An attribute describing encoded LWE plaintexts using bit fields. or An attribute describing unspecified bit field encodings.&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwemul_scalar-heirlwemulscalarop">&lt;code>lwe.mul_scalar&lt;/code> (heir::lwe::MulScalarOp)&lt;/h3>
&lt;p>&lt;em>Multiply an LWE ciphertext by a scalar&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.mul_scalar` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>scalar&lt;/code>&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweradd-heirlweraddop">&lt;code>lwe.radd&lt;/code> (heir::lwe::RAddOp)&lt;/h3>
&lt;p>&lt;em>Add two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.radd` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_decode-heirlwerlwedecodeop">&lt;code>lwe.rlwe_decode&lt;/code> (heir::lwe::RLWEDecodeOp)&lt;/h3>
&lt;p>&lt;em>Decode an RLWE plaintext to an underlying type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_decode` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>ring&lt;/code>&lt;/td>&lt;td>::mlir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_decrypt-heirlwerlwedecryptop">&lt;code>lwe.rlwe_decrypt&lt;/code> (heir::lwe::RLWEDecryptOp)&lt;/h3>
&lt;p>&lt;em>Decrypt an RLWE ciphertext to a RLWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_decrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Decrypt an RLWE ciphertext to yield a RLWE plaintext&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secret_key&lt;/code>&lt;/td>
&lt;td>A secret key for RLWE&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_encode-heirlwerlweencodeop">&lt;code>lwe.rlwe_encode&lt;/code> (heir::lwe::RLWEEncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode an integer to yield an RLWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_encode` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Encode an integer to yield an RLWE plaintext.&lt;/p>
&lt;p>This op uses a an encoding attribute to encode the bits of the integer into
an RLWE plaintext value that can then be encrypted. CKKS cleartext inputs may
be floating points, and a scaling factor described by the encoding will be
applied.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%Y = lwe.rlwe_encode %value {encoding = #enc, ring = #ring}: i1 to !lwe.rlwe_plaintext&amp;lt;encoding = #enc, ring = #ring&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>ring&lt;/code>&lt;/td>&lt;td>::mlir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer-like or floating-point-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_encrypt-heirlwerlweencryptop">&lt;code>lwe.rlwe_encrypt&lt;/code> (heir::lwe::RLWEEncryptOp)&lt;/h3>
&lt;p>&lt;em>Encrypt an RLWE plaintext to a RLWE ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_encrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Encrypt an RLWE plaintext to yield a RLWE ciphertext.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>key&lt;/code>&lt;/td>
&lt;td>A secret key for RLWE or A public key for RLWE&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwermul-heirlwermulop">&lt;code>lwe.rmul&lt;/code> (heir::lwe::RMulOp)&lt;/h3>
&lt;p>&lt;em>Multiplies two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rmul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameTypeOperands&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwernegate-heirlwernegateop">&lt;code>lwe.rnegate&lt;/code> (heir::lwe::RNegateOp)&lt;/h3>
&lt;p>&lt;em>Negate a RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rnegate` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwersub-heirlwersubop">&lt;code>lwe.rsub&lt;/code> (heir::lwe::RSubOp)&lt;/h3>
&lt;p>&lt;em>Subtract two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rsub` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwetrivial_encrypt-heirlwetrivialencryptop">&lt;code>lwe.trivial_encrypt&lt;/code> (heir::lwe::TrivialEncryptOp)&lt;/h3>
&lt;p>&lt;em>Create a trivial encryption of a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.trivial_encrypt` operands attr-dict `:` qualified(type(operands)) `to` qualified(type(results))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>params&lt;/code>&lt;/td>&lt;td>::mlir::heir::lwe::LWEParamsAttr&lt;/td>&lt;td>&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for LWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwereinterpret_underlying_type-heirlwereinterpretunderlyingtypeop">&lt;code>lwe.reinterpret_underlying_type&lt;/code> (heir::lwe::ReinterpretUnderlyingTypeOp)&lt;/h3>
&lt;p>&lt;em>A placeholder cast from one ciphertext type to another&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.reinterpret_underlying_type` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>The &lt;code>cast&lt;/code> op is thus used to translate &lt;code>underlying_type&lt;/code> between
ciphertexts in particular situations , such as when lowering to an API that
does not keep track of types for you.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: ModArith</title><link>https://heir.dev/docs/dialects/modarith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/modarith/</guid><description>
&lt;h2 id="modarith-ops">ModArith ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="mod_arithadd-heirmod_arithaddop">&lt;code>mod_arith.add&lt;/code> (heir::mod_arith::AddOp)&lt;/h3>
&lt;p>&lt;em>Modular addition operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.add` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes addition modulo a statically known modulus $q$.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithbarrett_reduce-heirmod_arithbarrettreduceop">&lt;code>mod_arith.barrett_reduce&lt;/code> (heir::mod_arith::BarrettReduceOp)&lt;/h3>
&lt;p>&lt;em>Compute the first step of the Barrett reduction.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.barrett_reduce` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Let $q$ denote a statically known modulus and $b = 4^{w}$, where $w$ is the
smallest bit-width that contains the range $[0, q)$. The Barrett reduce
operation computes &lt;code>barret_reduce x = x - floor(x * floor(b / q) / b) * q&lt;/code>.&lt;/p>
&lt;p>Given $0 &amp;lt;= x &amp;lt; q^2$, then this will compute $(x \mod q)$ or $(x \mod q) + p$.&lt;/p>
&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithmac-heirmod_arithmacop">&lt;code>mod_arith.mac&lt;/code> (heir::mod_arith::MacOp)&lt;/h3>
&lt;p>&lt;em>Modular multiplication-and-accumulation operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.mac` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.mac x, y, z {modulus = q}&lt;/code> computes $(x * y) + z \mod q$&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>acc&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithmul-heirmod_arithmulop">&lt;code>mod_arith.mul&lt;/code> (heir::mod_arith::MulOp)&lt;/h3>
&lt;p>&lt;em>Modular multiplication operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.mul` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes multiplication modulo a statically known modulus $q$.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithreduce-heirmod_arithreduceop">&lt;code>mod_arith.reduce&lt;/code> (heir::mod_arith::ReduceOp)&lt;/h3>
&lt;p>&lt;em>Reduce a signed integer to its congruence modulo equivalent&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.reduce` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.reduce x {modulus = q}&lt;/code> computes $y \in [0, q)$ such that
$x \equiv y \mod n$.&lt;/p>
&lt;p>Note this will interpret &lt;code>x&lt;/code> as a signed integer. For an unsigned integer,
equivalent functionality is: &lt;code>y = arith.remui x&lt;/code>.&lt;/p>
&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithsubifge-heirmod_arithsubifgeop">&lt;code>mod_arith.subifge&lt;/code> (heir::mod_arith::SubIfGEOp)&lt;/h3>
&lt;p>&lt;em>Compute (x &amp;gt;= y) ? x - y : x.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.subifge` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithsub-heirmod_arithsubop">&lt;code>mod_arith.sub&lt;/code> (heir::mod_arith::SubOp)&lt;/h3>
&lt;p>&lt;em>Modular subtraction operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.sub` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes subtraction modulo a statically known modulus $q$.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Openfhe</title><link>https://heir.dev/docs/dialects/openfhe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/openfhe/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The &lt;code>openfhe&lt;/code> dialect is an exit dialect for generating c++ code against the OpenFHE library API.&lt;/p>
&lt;p>See &lt;a href="https://github.com/openfheorg/openfhe-development">https://github.com/openfheorg/openfhe-development&lt;/a>&lt;/p>
&lt;h2 id="openfhe-types">Openfhe types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ccparamstype">CCParamsType&lt;/h3>
&lt;p>The CCParams required to create CryptoContext.&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.cc_params&lt;/code>&lt;/p>
&lt;h3 id="cryptocontexttype">CryptoContextType&lt;/h3>
&lt;p>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.crypto_context&lt;/code>&lt;/p>
&lt;h3 id="evalkeytype">EvalKeyType&lt;/h3>
&lt;p>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.eval_key&lt;/code>&lt;/p>
&lt;h3 id="privatekeytype">PrivateKeyType&lt;/h3>
&lt;p>The private key required to decrypt a ciphertext in OpenFHE.&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.private_key&lt;/code>&lt;/p>
&lt;h3 id="publickeytype">PublicKeyType&lt;/h3>
&lt;p>The public key required to encrypt plaintext in OpenFHE.&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.public_key&lt;/code>&lt;/p>
&lt;h2 id="openfhe-ops">Openfhe ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="openfheadd-heiropenfheaddop">&lt;code>openfhe.add&lt;/code> (heir::openfhe::AddOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE add operation of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheadd_plain-heiropenfheaddplainop">&lt;code>openfhe.add_plain&lt;/code> (heir::openfhe::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE add operation of a ciphertext and a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheautomorph-heiropenfheautomorphop">&lt;code>openfhe.automorph&lt;/code> (heir::openfhe::AutomorphOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.automorph` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evalKey&lt;/code>&lt;/td>
&lt;td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhedecrypt-heiropenfhedecryptop">&lt;code>openfhe.decrypt&lt;/code> (heir::openfhe::DecryptOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.decrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheencrypt-heiropenfheencryptop">&lt;code>openfhe.encrypt&lt;/code> (heir::openfhe::EncryptOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.encrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>publicKey&lt;/code>&lt;/td>
&lt;td>The public key required to encrypt plaintext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_context-heiropenfhegencontextop">&lt;code>openfhe.gen_context&lt;/code> (heir::openfhe::GenContextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_context` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The CCParams required to create CryptoContext.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>context&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_mulkey-heiropenfhegenmulkeyop">&lt;code>openfhe.gen_mulkey&lt;/code> (heir::openfhe::GenMulKeyOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_mulkey` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_params-heiropenfhegenparamsop">&lt;code>openfhe.gen_params&lt;/code> (heir::openfhe::GenParamsOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_params` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>mulDepth&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>plainMod&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The CCParams required to create CryptoContext.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_rotkey-heiropenfhegenrotkeyop">&lt;code>openfhe.gen_rotkey&lt;/code> (heir::openfhe::GenRotKeyOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_rotkey` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>indices&lt;/code>&lt;/td>&lt;td>::mlir::DenseI64ArrayAttr&lt;/td>&lt;td>i64 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhekey_switch-heiropenfhekeyswitchop">&lt;code>openfhe.key_switch&lt;/code> (heir::openfhe::KeySwitchOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.key_switch` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evalKey&lt;/code>&lt;/td>
&lt;td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhelevel_reduce-heiropenfhelevelreduceop">&lt;code>openfhe.level_reduce&lt;/code> (heir::openfhe::LevelReduceOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE level_reduce operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.level_reduce` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemake_ckks_packed_plaintext-heiropenfhemakeckkspackedplaintextop">&lt;code>openfhe.make_ckks_packed_plaintext&lt;/code> (heir::openfhe::MakeCKKSPackedPlaintextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.make_ckks_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of floating-point or integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemake_packed_plaintext-heiropenfhemakepackedplaintextop">&lt;code>openfhe.make_packed_plaintext&lt;/code> (heir::openfhe::MakePackedPlaintextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.make_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemod_reduce-heiropenfhemodreduceop">&lt;code>openfhe.mod_reduce&lt;/code> (heir::openfhe::ModReduceOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mod_reduce operation of a ciphertext. (used only for BGV/CKKS)&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mod_reduce` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_const-heiropenfhemulconstop">&lt;code>openfhe.mul_const&lt;/code> (heir::openfhe::MulConstOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of a ciphertext and a constant.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_const` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>constant&lt;/code>&lt;/td>
&lt;td>64-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_no_relin-heiropenfhemulnorelinop">&lt;code>openfhe.mul_no_relin&lt;/code> (heir::openfhe::MulNoRelinOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of two ciphertexts without relinearization.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_no_relin` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul-heiropenfhemulop">&lt;code>openfhe.mul&lt;/code> (heir::openfhe::MulOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of two ciphertexts with relinearization.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_plain-heiropenfhemulplainop">&lt;code>openfhe.mul_plain&lt;/code> (heir::openfhe::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of a ciphertext and a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A type for RLWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhenegate-heiropenfhenegateop">&lt;code>openfhe.negate&lt;/code> (heir::openfhe::NegateOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE negate operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.negate` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfherelin-heiropenfherelinop">&lt;code>openfhe.relin&lt;/code> (heir::openfhe::RelinOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE relinearize operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.relin` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfherot-heiropenfherotop">&lt;code>openfhe.rot&lt;/code> (heir::openfhe::RotOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.rot` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>index&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesquare-heiropenfhesquareop">&lt;code>openfhe.square&lt;/code> (heir::openfhe::SquareOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE square operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.square` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesub-heiropenfhesubop">&lt;code>openfhe.sub&lt;/code> (heir::openfhe::SubOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE sub operation of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for RLWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Polynomial</title><link>https://heir.dev/docs/dialects/polynomial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/polynomial/</guid><description>
&lt;h2 id="polynomial-additional-definitions">Polynomial additional definitions&lt;/h2></description></item><item><title>Docs: Random</title><link>https://heir.dev/docs/dialects/random/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/random/</guid><description>
&lt;h2 id="random-types">Random types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="distributiontype">DistributionType&lt;/h3>
&lt;p>A random distribution type&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!random.distribution&amp;lt;
::mlir::heir::random::Distribution # distribution_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A generic type, representing a specific random distribution type of either
uniform or gaussian as an attribute ($distribution_type).&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">distribution_type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::random::Distribution&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="prngtype">PRNGType&lt;/h3>
&lt;p>A pseudorandom number generator type&lt;/p>
&lt;p>Syntax: &lt;code>!random.prng&lt;/code>&lt;/p>
&lt;p>A type that provides pseudorandom number generator.&lt;/p>
&lt;h2 id="random-ops">Random ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="randomdiscrete_gaussian_distribution-heirrandomdiscretegaussiandistributionop">&lt;code>random.discrete_gaussian_distribution&lt;/code> (heir::random::DiscreteGaussianDistributionOp)&lt;/h3>
&lt;p>&lt;em>Initializes the Discrete Gaussian Distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.discrete_gaussian_distribution` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Initializes the Discrete Gaussian Distribution. The distribution is
initialized with a mean and a standard deviation and pseudorandom generator
that provides the source of the randomness.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>mean&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>stddev&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value whose value is non-negative&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randomdiscrete_uniform_distribution-heirrandomdiscreteuniformdistributionop">&lt;code>random.discrete_uniform_distribution&lt;/code> (heir::random::DiscreteUniformDistributionOp)&lt;/h3>
&lt;p>&lt;em>Initializes the Discrete Uniform Distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.discrete_uniform_distribution` $input `{` `range` `=` `[` $min `,` $max `]` `}` attr-dict `:` `(` qualified(type($input)) `)` `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>Initializes the Discrete Uniform Distribution. The distribution is
initialized with a minimum and a maximum value and pseudo random generator
that provides the source of the randomness. The distribution is inclusive of
the minimum and exclusive of the maximum.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>min&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>max&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randominit_prng-heirrandominitop">&lt;code>random.init_prng&lt;/code> (heir::random::InitOp)&lt;/h3>
&lt;p>&lt;em>Initializes the pseudorandom number generator with a seed.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.init_prng` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Initializes the PRNG with a seed. The seed is dynamically provided due to
protocols that agree on shared randomness. The PRNG is used to initialized
the random distributions such as the discrete gaussian distribution and the
discrete uniform distribution. This initialization also takes as input a
number of bits that are generated for each number value sampled (num_bits).
For instance, a num_bits of 32 will mean that distributions will generate a
32-bit integer value. We expect that the seed initialization is done statically
and globally once per thread for all distributions; however, if multiple threads are
generating randomness, then seed initialization should be done per thread;
otherwise there is no guarantee of consistent behavior. Thread safety is so
far not considered.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>num_bits&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>seed&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randomsample-heirrandomsampleop">&lt;code>random.sample&lt;/code> (heir::random::SampleOp)&lt;/h3>
&lt;p>&lt;em>Samples from a distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.sample` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Samples from the distribution to obtain a random value
or tensor of values.&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: RNS</title><link>https://heir.dev/docs/dialects/rns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/rns/</guid><description>
&lt;h2 id="rns-types">RNS types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="rnstype">RNSType&lt;/h3>
&lt;p>A residue number system representation&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!rns.rns&amp;lt;
::llvm::ArrayRef&amp;lt;mlir::Type&amp;gt; # basisTypes
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">basisTypes&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;mlir::Type&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="rns-ops">RNS ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h2 id="rns-additional-definitions">RNS additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="typeinterface-definitions">TypeInterface definitions&lt;/h1>
&lt;h2 id="rnsbasistypeinterface-rnsbasistypeinterface">RNSBasisTypeInterface (&lt;code>RNSBasisTypeInterface&lt;/code>)&lt;/h2>
&lt;p>This interface is required for a type to be used as a parameter
to an &lt;code>rns&lt;/code> type.&lt;/p>
&lt;h3 id="methods">Methods:&lt;/h3>
&lt;h4 id="iscompatiblewith">&lt;code>isCompatibleWith&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">isCompatibleWith&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">mlir&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">Type&lt;/span> &lt;span style="color:#000">otherRnsBasisType&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Returns true if this type is compatible with another type in the
same RNS basis. In particular, the set of types used for a single
RNS basis are never equal as types, but instead have some common
attribute that must be checked here. For example, an RNS type where
the basis types are polynomials would return true if the two types
are both polynomial types, even if they have different coefficient
moduli.&lt;/p>
&lt;p>&lt;code>isCompatibleWith&lt;/code> must be both commutative and associative, in the sense
that &lt;code>type1.isCompatibleWith(type2)&lt;/code> if and only if
&lt;code>type2.isCompatibleWith(type1)&lt;/code>, and further
&lt;code>type2.isCompatibleWith(type3)&lt;/code> if and only if
&lt;code>type1.isCompatibleWith(type3)&lt;/code>.&lt;/p>
&lt;p>NOTE: This method &lt;em>must&lt;/em> be implemented by the user.&lt;/p></description></item><item><title>Docs: Secret</title><link>https://heir.dev/docs/dialects/secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/secret/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>Secret is a dialect for computations that operate on encrypted data.&lt;/p>
&lt;p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.&lt;/p>
&lt;h2 id="secret-types">Secret types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="secrettype">SecretType&lt;/h3>
&lt;p>A secret value&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!secret.secret&amp;lt;
Type # valueType
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">valueType&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="secret-ops">Secret ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="secretcast-heirsecretcastop">&lt;code>secret.cast&lt;/code> (heir::secret::CastOp)&lt;/h3>
&lt;p>&lt;em>A placeholder cast from one secret type to another&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.cast` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>A &lt;code>cast&lt;/code> operation represents a type cast from one secret type to another,
that is used to enable the intermixing of various equivalent secret types
before a lower-level FHE scheme has been chosen.&lt;/p>
&lt;p>For example, &lt;code>secret.cast&lt;/code> can be used to convert a &lt;code>secret&amp;lt;i8&amp;gt;&lt;/code> to a
&lt;code>secret&amp;lt;tensor&amp;lt;8xi1&amp;gt;&amp;gt;&lt;/code> as a compatibility layer between boolean and
non-boolean parts of a program. The pass that later lowers the IR to
specific FHE schemes would need to replace these casts with appropriate
scheme-specific operations, and it is left to those later passes to
determine which casts are considered valid.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%result&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>cast &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> to &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">8x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%result2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>cast &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> to &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretconceal-heirsecretconcealop">&lt;code>secret.conceal&lt;/code> (heir::secret::ConcealOp)&lt;/h3>
&lt;p>&lt;em>Convert a non-secret value into a secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.conceal` $cleartext attr-dict `:` type($cleartext) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>Convert a value to a secret containing the same value.&lt;/p>
&lt;p>This op represents a scheme-agnostic encryption operation, as well as a
&amp;ldquo;trivial encryption&amp;rdquo; operation which is needed for some FHE schemes. This
op is also useful for type materialization in the dialect conversion
framework.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>conceal &lt;span style="color:#000">%value&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cleartext&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretgeneric-heirsecretgenericop">&lt;code>secret.generic&lt;/code> (heir::secret::GenericOp)&lt;/h3>
&lt;p>&lt;em>Lift a plaintext computation to operate on secrets.&lt;/em>&lt;/p>
&lt;p>&lt;code>secret.generic&lt;/code> lifts a plaintext computation to operate on one or more
secrets. The lifted computation is represented as a region containing a
single block terminated by &lt;code>secret.yield&lt;/code>. The arguments of the &lt;code>secret.generic&lt;/code>
may include one or more &lt;code>!secret.secret&lt;/code> types. The arguments of the block
in the op&amp;rsquo;s body correspond to the underlying plaintext types of the secrets.&lt;/p>
&lt;p>&lt;code>secret.generic&lt;/code> is not isolated from above, so you may directly reference
values in the enclosing scope. This is required to support using
&lt;code>secret.generic&lt;/code> inside of ops with &lt;code>AffineScope&lt;/code>, while having the body
of the generic use the induction variables defined by the affine scope.&lt;/p>
&lt;p>Basic examples:&lt;/p>
&lt;p>Add two secret integers together&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic ins&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Add a secret value with a plaintext value. I.e., not all arguments to the
op need be secret.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic ins&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The same as above, but the plaintext op is not passed through the basic
block.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic ins&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>SingleBlockImplicitTerminator&amp;lt;YieldOp&amp;gt;&lt;/code>, &lt;code>SingleBlock&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>results&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretreveal-heirsecretrevealop">&lt;code>secret.reveal&lt;/code> (heir::secret::RevealOp)&lt;/h3>
&lt;p>&lt;em>Convert a secret value into a non-secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.reveal` $input attr-dict `:` type($input) `-&amp;gt;` type($cleartext)
&lt;/code>&lt;/pre>&lt;p>Convert a secret into a non-secret containing the same value.&lt;/p>
&lt;p>This op represents a scheme-agnostic decryption operation. This op is also
useful for target materialization in the dialect conversion framework.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>reveal &lt;span style="color:#000">%secret_value&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cleartext&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretseparator-heirsecretseparatorop">&lt;code>secret.separator&lt;/code> (heir::secret::SeparatorOp)&lt;/h3>
&lt;p>&lt;em>Convert a non-secret value into a secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.separator` attr-dict ($inputs^ `:` type($inputs))?
&lt;/code>&lt;/pre>&lt;p>This operation is used as a separation boundary between logical subunits of
the module. This is used in conjunction with
&lt;code>--secret-distribute-generic=distribute-through=secret.separator&lt;/code> to break a
generic around these separators and allow for optimization passses to
analyze and optimize the sub-units locally.&lt;/p>
&lt;p>In order to allow bufferization of modules with this operation, we must
register a (bogus) memory effect that also prevents this operation from
being trivially dead during operation folding.&lt;/p>
&lt;p>This operation also accepts operands, which act as boundaries between the
logical units. This enforces separation of memref and affine optimizations
between the subunits, preventing optimizations from removing the operand and
combining the two separated regions. The operand can be thought of as an
return value of the logical subunit.&lt;/p>
&lt;p>Interfaces: &lt;code>MemoryEffectOpInterface (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretyield-heirsecretyieldop">&lt;code>secret.yield&lt;/code> (heir::secret::YieldOp)&lt;/h3>
&lt;p>&lt;em>Secret yield operation&lt;/em>&lt;/p>
&lt;p>&lt;code>secret.yield&lt;/code> is a special terminator operation for blocks inside regions
in &lt;code>secret&lt;/code> generic ops. It returns the cleartext value of the
corresponding private computation to the immediately enclosing &lt;code>secret&lt;/code>
generic op.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>HasParent&amp;lt;GenericOp&amp;gt;&lt;/code>, &lt;code>ReturnLike&lt;/code>, &lt;code>Terminator&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>, &lt;code>RegionBranchTerminatorOpInterface&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>values&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TensorExt</title><link>https://heir.dev/docs/dialects/tensorext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tensorext/</guid><description>
&lt;h2 id="tensorext-attributes">TensorExt attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="simdpackingattr">SIMDPackingAttr&lt;/h3>
&lt;p>An attribute describing the SIMD packing of a tensor.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#tensor_ext.simd_packing&amp;lt;
::mlir::DenseI64ArrayAttr, # in
::mlir::DenseI64ArrayAttr, # padding
::mlir::DenseI64ArrayAttr, # out
int64_t # padding_value
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used as the encoding attribute on a tensor. It describes
the transformations that were applied to an input tensor to pack it into the
given tensor.&lt;/p>
&lt;p>The &lt;code>in&lt;/code> attribute describes the shape of the original tensor.
The following transformations are applied to the input tensor.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Padding is applied first. The &lt;code>padding&lt;/code> attribute is an array with the
same size as the input tensor shape. Padding is applied at the end of
the array using the &lt;code>padding_value&lt;/code> attribute (default zero). The
result after zero padding should be a power of two.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The padded result is replicated or split to fill the output tensor
shape.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>#packing = #tensor_ext.simd_packing&amp;lt;
in = [7],
padding = [1],
padding_value = 0,
out = [16],
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>may be used on a tensor type like&lt;/p>
&lt;pre tabindex="0">&lt;code>tensor&amp;lt;1x16xi32, #packing&amp;gt;
&lt;/code>&lt;/pre>&lt;p>If the original tensor had values &lt;code>[1, 2, 3, 4, 5, 6, 7]&lt;/code> then a tensor with
this attribute contains the data &lt;code>[1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0]&lt;/code>.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">in&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">padding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">out&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">padding_value&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tensorext-ops">TensorExt ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tensor_extrotate-heirtensor_extrotateop">&lt;code>tensor_ext.rotate&lt;/code> (heir::tensor_ext::RotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate a tensor some number of indices left.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.rotate` operands attr-dict `:` qualified(type($tensor)) `,` type($shift)
&lt;/code>&lt;/pre>&lt;p>This op represents a left-rotation of a tensor by given number of indices.
Negative shift values are interpreted as right-rotations.&lt;/p>
&lt;p>This corresponds to the &lt;code>rotate&lt;/code> operation in arithmetic FHE schemes like
BGV.&lt;/p>
&lt;p>This operation&amp;rsquo;s current behavior allows rotating multi-dimensional tensors
by rotating along the tensor&amp;rsquo;s only non-unit dimension. This assumes the
tensor is packed along the non-unit dimension.&lt;/p>
&lt;p>// In the future, the op will be adjusted to support rotations of general
// multi-dimensional tensors with a vector of rotation indices for each
// dimension. The lowering will implement the correct operations to rotate
// the tensor along the indices given its packing.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">...&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">16x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%c7&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>_ext&lt;span style="color:#000;font-weight:bold">.&lt;/span>rotate &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c7&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">16x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>tensor&lt;/code>&lt;/td>
&lt;td>tensor of any type values&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>shift&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TfheRust</title><link>https://heir.dev/docs/dialects/tfherust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tfherust/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The &lt;code>thfe_rust&lt;/code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the shortint parameters and encoding scheme.&lt;/p>
&lt;p>See &lt;a href="https://github.com/zama-ai/tfhe-rs">https://github.com/zama-ai/tfhe-rs&lt;/a>&lt;/p>
&lt;h2 id="tfherust-types">TfheRust types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="encryptedint8type">EncryptedInt8Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei8&lt;/code>&lt;/p>
&lt;h3 id="encryptedint16type">EncryptedInt16Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei16&lt;/code>&lt;/p>
&lt;h3 id="encryptedint32type">EncryptedInt32Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei32&lt;/code>&lt;/p>
&lt;h3 id="encryptedint64type">EncryptedInt64Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei64&lt;/code>&lt;/p>
&lt;h3 id="encryptedint128type">EncryptedInt128Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei128&lt;/code>&lt;/p>
&lt;h3 id="encryptedint256type">EncryptedInt256Type&lt;/h3>
&lt;p>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei256&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint2type">EncryptedUInt2Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui2&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint3type">EncryptedUInt3Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui3&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint4type">EncryptedUInt4Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui4&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint8type">EncryptedUInt8Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui8&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint10type">EncryptedUInt10Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui10&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint12type">EncryptedUInt12Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui12&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint14type">EncryptedUInt14Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui14&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint16type">EncryptedUInt16Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui16&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint32type">EncryptedUInt32Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui32&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint64type">EncryptedUInt64Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui64&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint128type">EncryptedUInt128Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui128&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint256type">EncryptedUInt256Type&lt;/h3>
&lt;p>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui256&lt;/code>&lt;/p>
&lt;h3 id="lookuptabletype">LookupTableType&lt;/h3>
&lt;p>A univariate lookup table used for programmable bootstrapping.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.lookup_table&lt;/code>&lt;/p>
&lt;h3 id="serverkeytype">ServerKeyType&lt;/h3>
&lt;p>The short int server key required to perform homomorphic operations.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.server_key&lt;/code>&lt;/p>
&lt;h2 id="tfherust-ops">TfheRust ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfhe_rustapply_lookup_table-heirtfhe_rustapplylookuptableop">&lt;code>tfhe_rust.apply_lookup_table&lt;/code> (heir::tfhe_rust::ApplyLookupTableOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.apply_lookup_table` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lookupTable&lt;/code>&lt;/td>
&lt;td>A univariate lookup table used for programmable bootstrapping.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustcreate_trivial-heirtfhe_rustcreatetrivialop">&lt;code>tfhe_rust.create_trivial&lt;/code> (heir::tfhe_rust::CreateTrivialOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.create_trivial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustgenerate_lookup_table-heirtfhe_rustgeneratelookuptableop">&lt;code>tfhe_rust.generate_lookup_table&lt;/code> (heir::tfhe_rust::GenerateLookupTableOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.generate_lookup_table` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>truthTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lookupTable&lt;/code>&lt;/td>
&lt;td>A univariate lookup table used for programmable bootstrapping.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustscalar_left_shift-heirtfhe_rustscalarleftshiftop">&lt;code>tfhe_rust.scalar_left_shift&lt;/code> (heir::tfhe_rust::ScalarLeftShiftOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.scalar_left_shift` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>shiftAmount&lt;/code>&lt;/td>
&lt;td>8-bit integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustadd-heirtfhe_rustaddop">&lt;code>tfhe_rust.add&lt;/code> (heir::tfhe_rust::AddOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic add of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustbitand-heirtfhe_rustbitandop">&lt;code>tfhe_rust.bitand&lt;/code> (heir::tfhe_rust::BitAndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.bitand` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustsub-heirtfhe_rustsubop">&lt;code>tfhe_rust.sub&lt;/code> (heir::tfhe_rust::SubOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic sub of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TfheRustBool</title><link>https://heir.dev/docs/dialects/tfherustbool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tfherustbool/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The &lt;code>tfhe_rust_bool&lt;/code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the boolean parameter set.&lt;/p>
&lt;p>See &lt;a href="https://github.com/zama-ai/tfhe-rs">https://github.com/zama-ai/tfhe-rs&lt;/a>&lt;/p>
&lt;h2 id="tfherustbool-types">TfheRustBool types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="booleangateandtype">BooleanGateAndType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateAnd to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateAnd&lt;/code>&lt;/p>
&lt;h3 id="booleangatenandtype">BooleanGateNandType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateNand to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateNand&lt;/code>&lt;/p>
&lt;h3 id="booleangatenortype">BooleanGateNorType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateNor to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateNor&lt;/code>&lt;/p>
&lt;h3 id="booleangateortype">BooleanGateOrType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateOr to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateOr&lt;/code>&lt;/p>
&lt;h3 id="booleangatexnortype">BooleanGateXnorType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateXnor to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateXnor&lt;/code>&lt;/p>
&lt;h3 id="booleangatexortype">BooleanGateXorType&lt;/h3>
&lt;p>Enum placeholder to define the binary gateXor to perform as homomoprhic operation.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.bin_gateXor&lt;/code>&lt;/p>
&lt;h3 id="encryptedbooltype">EncryptedBoolType&lt;/h3>
&lt;p>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.eb&lt;/code>&lt;/p>
&lt;h3 id="serverkeytype">ServerKeyType&lt;/h3>
&lt;p>The boolean server key required to perform homomorphic operations.&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.server_key&lt;/code>&lt;/p>
&lt;h2 id="tfherustbool-ops">TfheRustBool ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfhe_rust_boolcreate_trivial-heirtfhe_rust_boolcreatetrivialop">&lt;code>tfhe_rust_bool.create_trivial&lt;/code> (heir::tfhe_rust_bool::CreateTrivialOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.create_trivial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_booland-heirtfhe_rust_boolandop">&lt;code>tfhe_rust_bool.and&lt;/code> (heir::tfhe_rust_bool::AndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.and` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolmux-heirtfhe_rust_boolmuxop">&lt;code>tfhe_rust_bool.mux&lt;/code> (heir::tfhe_rust_bool::MuxOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.mux` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cnd&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnand-heirtfhe_rust_boolnandop">&lt;code>tfhe_rust_bool.nand&lt;/code> (heir::tfhe_rust_bool::NandOp)&lt;/h3>
&lt;p>&lt;em>Logical NAND of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.nand` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnor-heirtfhe_rust_boolnorop">&lt;code>tfhe_rust_bool.nor&lt;/code> (heir::tfhe_rust_bool::NorOp)&lt;/h3>
&lt;p>&lt;em>Logical NOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.nor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnot-heirtfhe_rust_boolnotop">&lt;code>tfhe_rust_bool.not&lt;/code> (heir::tfhe_rust_bool::NotOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.not` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolor-heirtfhe_rust_boolorop">&lt;code>tfhe_rust_bool.or&lt;/code> (heir::tfhe_rust_bool::OrOp)&lt;/h3>
&lt;p>&lt;em>Logical OR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.or` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolpacked-heirtfhe_rust_boolpackedop">&lt;code>tfhe_rust_bool.packed&lt;/code> (heir::tfhe_rust_bool::PackedOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.packed` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>gates&lt;/code>&lt;/td>
&lt;td>Enum placeholder to define the binary gateAnd to perform as homomoprhic operation. or Enum placeholder to define the binary gateOr to perform as homomoprhic operation. or Enum placeholder to define the binary gateXor to perform as homomoprhic operation. or Enum placeholder to define the binary gateNand to perform as homomoprhic operation. or Enum placeholder to define the binary gateNor to perform as homomoprhic operation. or Enum placeholder to define the binary gateXnor to perform as homomoprhic operation.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolxnor-heirtfhe_rust_boolxnorop">&lt;code>tfhe_rust_bool.xnor&lt;/code> (heir::tfhe_rust_bool::XnorOp)&lt;/h3>
&lt;p>&lt;em>Logical XNOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.xnor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolxor-heirtfhe_rust_boolxorop">&lt;code>tfhe_rust_bool.xor&lt;/code> (heir::tfhe_rust_bool::XorOp)&lt;/h3>
&lt;p>&lt;em>Logical XOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.xor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>